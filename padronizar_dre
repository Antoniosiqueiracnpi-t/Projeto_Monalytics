import pandas as pd
import os
import numpy as np

def padronizar_dre(tickers_input, diretorio_base='balancos'):
    """
    Padroniza o DRE aplicando regras de negócios específicas:
    - Filtra contas padrão (3.01 a 3.11).
    - Trata conta 3.99 (Lucro por Ação) somando ON+PN se diferentes.
    - Calcula T4 isolado subtraindo T1+T2+T3 do Anual.
    - Realiza check-up de consistência.
    
    Args:
        tickers_input (str ou list): Ticker único ('PETR4') ou lista (['PETR4', 'VALE3']).
        diretorio_base (str): Caminho da pasta onde estão os balanços.
        
    Returns:
        dict: Dicionário {ticker: pd.DataFrame} com os dados organizados.
    """
    
    # Normalizar entrada para lista
    if isinstance(tickers_input, str):
        tickers = [tickers_input]
    else:
        tickers = tickers_input

    resultados = {}

    # Mapeamento das contas permitidas
    contas_alvo = {
        '3.01': 'Receita de Venda de Bens e/ou Serviços',
        '3.02': 'Custo dos Bens e/ou Serviços Vendidos',
        '3.03': 'Resultado Bruto',
        '3.04': 'Despesas/Receitas Operacionais',
        '3.05': 'Resultado Antes do Resultado Financeiro e dos Tributos',
        '3.06': 'Resultado Financeiro',
        '3.07': 'Resultado Antes dos Tributos sobre o Lucro',
        '3.08': 'Imposto de Renda e Contribuição Social sobre o Lucro',
        '3.09': 'Resultado Líquido das Operações Continuadas',
        '3.10': 'Resultado Líquido de Operações Descontinuadas',
        '3.11': 'Lucro/Prejuízo Consolidado do Período',
        '3.99': 'Lucro por Ação'
    }

    print(f"Iniciando padronização para {len(tickers)} ativos...")

    for ticker in tickers:
        print(f"Processando {ticker}...")
        
        # Definir caminhos
        path_cons = os.path.join(diretorio_base, ticker, 'dre_consolidado.csv')
        path_anual = os.path.join(diretorio_base, ticker, 'dre_anual.csv')

        # Verificação de existência
        if not (os.path.exists(path_cons) and os.path.exists(path_anual)):
            print(f"  [AVISO] Arquivos não encontrados para {ticker}. Pulando.")
            continue

        try:
            # Leitura dos arquivos (tentando engine python para robustez com separadores)
            df_cons = pd.read_csv(path_cons, sep=None, engine='python')
            df_anual = pd.read_csv(path_anual, sep=None, engine='python')
        except Exception as e:
            print(f"  [ERRO] Falha ao ler arquivos de {ticker}: {e}")
            continue

        # --- Pré-processamento e Tipagem ---
        for df in [df_cons, df_anual]:
            df['data_fim'] = pd.to_datetime(df['data_fim'])
            df['valor_mil'] = pd.to_numeric(df['valor_mil'], errors='coerce').fillna(0.0)
            df['cd_conta'] = df['cd_conta'].astype(str).str.strip()
            df['ano'] = df['data_fim'].dt.year
            # Garante que coluna trimestre exista
            if 'trimestre' not in df.columns:
                 # Inferência simples caso falte
                df['trimestre'] = df['data_fim'].dt.month.map({3:'T1', 6:'T2', 9:'T3', 12:'T4'})

        # --- Lógica Especial: Conta 3.99 (Lucro por Ação) ---
        def tratar_lucro_acao(df_orig):
            # Separa o que é 3.99 do resto
            mask_lpa = df_orig['cd_conta'].str.startswith('3.99')
            df_lpa_raw = df_orig[mask_lpa]
            df_outros = df_orig[~mask_lpa]
            
            lpa_rows = []
            
            # Agrupa por data/trimestre para consolidar duplicidades ou somar ON+PN
            if not df_lpa_raw.empty:
                for (data, tri), grupo in df_lpa_raw.groupby(['data_fim', 'trimestre']):
                    # Pega valores únicos diferentes de zero
                    valores_unicos = grupo.loc[grupo['valor_mil'] != 0, 'valor_mil'].unique()
                    
                    valor_final = 0.0
                    if len(valores_unicos) > 0:
                        # Se houver valores diferentes (ex: ON e PN com valores distintos), soma.
                        # Se houver duplicatas exatas, o .unique() já removeu, então não soma duplicado.
                        valor_final = valores_unicos.sum()
                    
                    lpa_rows.append({
                        'data_fim': data,
                        'trimestre': tri,
                        'cd_conta': '3.99',
                        'ds_conta': 'Lucro por Ação',
                        'valor_mil': valor_final,
                        'ano': data.year
                    })
            
            # Retorna o dataframe sem as contas 3.99 antigas e com a nova linha consolidada
            if lpa_rows:
                df_lpa_clean = pd.DataFrame(lpa_rows)
                return pd.concat([df_outros, df_lpa_clean], ignore_index=True)
            return df_outros

        df_cons = tratar_lucro_acao(df_cons)
        df_anual = tratar_lucro_acao(df_anual)

        # --- Filtragem das Contas Alvo ---
        df_cons = df_cons[df_cons['cd_conta'].isin(contas_alvo.keys())]
        df_anual = df_anual[df_anual['cd_conta'].isin(contas_alvo.keys())]

        # --- Consolidação Temporal (Cálculo do T4) ---
        dados_finais = []
        anos = sorted(df_anual['ano'].unique())

        for ano in anos:
            df_anual_ano = df_anual[df_anual['ano'] == ano]
            df_cons_ano = df_cons[df_cons['ano'] == ano]

            for conta, desc in contas_alvo.items():
                # Busca valor anual (referência)
                linha_anual = df_anual_ano[df_anual_ano['cd_conta'] == conta]
                valor_anual = linha_anual['valor_mil'].values[0] if not linha_anual.empty else None

                if valor_anual is None: continue # Sem referência anual, pula

                # Busca trimestres disponíveis no consolidado
                linhas_cons = df_cons_ano[df_cons_ano['cd_conta'] == conta]
                
                trimestres_encontrados = set()
                soma_trimestres = 0.0

                # Adiciona trimestres existentes (T1, T2, T3 ou até T4 se já vier pronto)
                for _, row in linhas_cons.iterrows():
                    tri = row['trimestre']
                    dados_finais.append(row.to_dict())
                    trimestres_encontrados.add(tri)
                    if tri in ['T1', 'T2', 'T3']:
                        soma_trimestres += row['valor_mil']

                # Lógica do T4
                if 'T4' not in trimestres_encontrados:
                    if {'T1', 'T2', 'T3'}.issubset(trimestres_encontrados):
                        # Temos T1, T2, T3 -> Calcula T4 Residual
                        valor_t4 = valor_anual - soma_trimestres
                        dados_finais.append({
                            'data_fim': pd.Timestamp(f'{ano}-12-31'),
                            'trimestre': 'T4',
                            'cd_conta': conta,
                            'ds_conta': desc,
                            'valor_mil': valor_t4,
                            'ano': ano
                        })
                    else:
                        # Falta algum trimestre (ex: só tem T1 e T2). 
                        # Não calculamos T4 para não gerar dados inconsistentes/acumulados errados.
                        pass

        if not dados_finais:
            print(f"  [AVISO] Nenhum dado restou após processamento de {ticker}.")
            continue

        df_final = pd.DataFrame(dados_finais)

        # --- Check-up de Consistência ---
        # Verifica se a soma dos 4 trimestres bate com o valor anual original
        discrepancias = 0
        for ano in anos:
            for conta in contas_alvo.keys():
                subset = df_final[(df_final['ano'] == ano) & (df_final['cd_conta'] == conta)]
                # Só verifica se tivermos o ano completo (4 trimestres)
                if len(subset) == 4:
                    soma_calculada = subset['valor_mil'].sum()
                    
                    # Valor original
                    val_orig = df_anual[(df_anual['ano'] == ano) & (df_anual['cd_conta'] == conta)]['valor_mil'].values
                    if len(val_orig) > 0:
                        diff = abs(soma_calculada - val_orig[0])
                        if diff > 0.05: # Margem de erro float
                            discrepancias += 1
                            # print(f"    Check falhou {ano} {conta}: Calc {soma_calculada:.2f} != Real {val_orig[0]:.2f}")
        
        if discrepancias == 0:
            print("  Check-up: OK (Consistência 100%)")
        else:
            print(f"  Check-up: Encontradas {discrepancias} pequenas discrepâncias de arredondamento.")

        # --- Formatação Horizontal ---
        # Pivot: Linhas (Contas), Colunas (Datas)
        df_pivot = df_final.pivot_table(
            index=['cd_conta', 'ds_conta'], 
            columns='data_fim', 
            values='valor_mil'
        )
        
        # Ordenar colunas cronologicamente
        df_pivot = df_pivot.sort_index(axis=1)
        
        # Salva no dicionário de resultados
        resultados[ticker] = df_pivot

    return resultados

# Exemplo de uso (comentado):
# dfs = padronizar_dre(['VIVA3', 'PETR4'])
# print(dfs['VIVA3'].head())
